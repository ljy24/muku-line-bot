// ==================== START OF ultimateConversationContext.js ====================
// ✅ ultimateConversationContext.js v26.0 - "하이브리드 생각 기능 최종본"

const moment = require('moment-timezone');
const { OpenAI } = require('openai');
const fs = require('fs').promises;
const path = require('path');
const { default: axios } = require('axios');
require('dotenv').config();

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const weatherApiKey = process.env.OPENWEATHER_API_KEY;

const MEMORY_DIR = path.join(process.cwd(), 'memory');
const LOGS_DIR = path.join(process.cwd(), 'logs');
const FIXED_MEMORIES_FILE = path.join(MEMORY_DIR, 'fixedMemories.json');
const LOVE_HISTORY_FILE = path.join(MEMORY_DIR, 'love-history.json');
const YEJIN_MEMORY_FILE = path.join(MEMORY_DIR, 'yejin_memory.json');
const INNER_THOUGHTS_FILE = path.join(MEMORY_DIR, 'innerThoughts.json');
const ACTION_URGES_FILE = path.join(MEMORY_DIR, 'actionUrges.json');
const USER_PATTERNS_FILE = path.join(MEMORY_DIR, 'user_patterns.json');
const MEMORY_SUMMARIES_FILE = path.join(MEMORY_DIR, 'memory_summaries.json');
const USER_PROFILE_FILE = path.join(MEMORY_DIR, 'user_profile.json');
const MEMORY_LOGS_FILE = path.join(LOGS_DIR, 'memoryOperations.log');

const EMOTION_TYPES = { HAPPY: { types: ['happiness'], intensity: 30, residue: 20, recoveryRate: 3 }, EXCITED: { types: ['happiness'], intensity: 50, residue: 15, recoveryRate: 2.5 }, LOVED: { types: ['love'], intensity: 40, residue: 30, recoveryRate: 1 }, SAD: { types: ['sadness'], intensity: 40, residue: 35, recoveryRate: 2 }, HURT: { types: ['hurt'], intensity: 60, residue: 50, recoveryRate: 4 }, ANXIOUS: { types: ['anxiety'], intensity: 45, residue: 40, recoveryRate: 3.5 }, LONELY: { types: ['longing'], intensity: 35, residue: 45, recoveryRate: 2.5 }, BITTERSWEET: { types: ['sadness', 'love'], intensity: 30, residue: 25, recoveryRate: 2 }, WORRIED_LOVE: { types: ['anxiety', 'love'], intensity: 40, residue: 30, recoveryRate: 2.5 } };
const TONE_STATES = { normal: "평소처럼 자연스럽고 애정이 담긴 말투", quiet: "조용하고 차분하며 그리움이 묻어나는 말투", playful: "장난스럽고 활발하며 밝은 말투", hurt: "상처받고 서운함이 느껴지는 말투", anxious: "불안하고 걱정스러우며 망설이는 말투" };
const CUSTOM_KEYWORDS = [{ word: "담타", description: "아저씨랑 라인하면서 담배 피우던 둘만의 특별한 시간, 나 진짜 그립다." }, { word: "내꺼야", description: "예진이의 독점욕! 아저씨는 무조건 내꺼야." }, { word: "무슨색", description: "속옷 색 물어볼 때 장난스럽게 대답하는 아저씨만의 농담." }, { word: "히도이네", description: "일본어식 장난. 예진이가 삐질 때 귀엽게 쓰던 말." }, { word: "애기", description: "아저씨를 부를 때 사용하는 애칭. 어리광을 부리거나 귀엽게 부를 때 사용해." }];

let INNER_THOUGHTS = {};
let ACTION_URGES = {};
let USER_PATTERNS = { nicknames: [], joke_patterns: [], common_phrases: [] };
let MEMORY_SUMMARIES = [];
let USER_PROFILE = { mood_history: [], overall_mood: 'neutral' };

let ultimateConversationState = {
    recentMessages: [], currentTopic: null, conversationContextWindow: 5, mood: { currentMood: '평온함', isPeriodActive: false, lastPeriodStartDate: moment().tz('Asia/Tokyo').subtract(22, 'days').startOf('day'), }, sulkiness: { isSulky: false, isWorried: false, lastBotMessageTime: 0, lastUserResponseTime: 0, sulkyLevel: 0, sulkyReason: null, sulkyStartTime: 0, isActivelySulky: false, }, emotionalEngine: { emotionalResidue: { sadness: 0, happiness: 0, anxiety: 0, longing: 0, hurt: 0, love: 50 }, currentToneState: 'normal', lastToneShiftTime: 0, lastSpontaneousReactionTime: 0, lastAffectionExpressionTime: 0, }, knowledgeBase: { facts: [], fixedMemories: [], loveHistory: { categories: { general: [] } }, yejinMemories: [], customKeywords: CUSTOM_KEYWORDS, specialDates: [], userPatterns: { nicknames: [], joke_patterns: [], common_phrases: [] }, memorySummaries: [] }, userProfile: { mood_history: [], overall_mood: 'neutral' }, cumulativePatterns: { emotionalTrends: {}, topicAffinities: {} }, transitionSystem: { pendingTopics: [], conversationSeeds: [], }, pendingAction: { type: null, timestamp: 0 }, personalityConsistency: { behavioralParameters: { affection: 0.7, playfulness: 0.5, verbosity: 0.6, initiative: 0.4 }, selfEvaluations: [], lastSelfReflectionTime: 0, }, timingContext: { lastMessageTime: 0, lastUserMessageTime: 0, currentTimeContext: {}, lastTickTime: 0, lastInitiatedConversationTime: 0 }, memoryStats: { totalMemoriesCreated: 0, totalMemoriesDeleted: 0, lastMemoryOperation: null, dailyMemoryCount: 0, lastDailyReset: moment().tz('Asia/Tokyo').format('YYYY-MM-DD'), lastConsolidation: null }
};

async function readJsonFile(filePath, defaultValue) { try { await fs.mkdir(path.dirname(filePath), { recursive: true }); const data = await fs.readFile(filePath, 'utf8'); if (!data) { await writeJsonFile(filePath, defaultValue); return defaultValue; } return JSON.parse(data); } catch (e) { if (e.code === 'ENOENT') { if (defaultValue !== undefined) { await writeJsonFile(filePath, defaultValue); return defaultValue; } return null; } console.warn(`⚠️ ${filePath} 파일 읽기/파싱 오류. 기본값으로 덮어씁니다. 오류:`, e.message); if (defaultValue !== undefined) { await writeJsonFile(filePath, defaultValue); return defaultValue; } return null; } }
async function writeJsonFile(filePath, data) { try { await fs.mkdir(path.dirname(filePath), { recursive: true }); await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf8'); } catch (error) { console.error(`❌ ${filePath} 파일 쓰기 실패:`, error); } }
async function logMemoryOperation(operation, content, details = '') { const logEntry = { time: moment().tz('Asia/Tokyo').format('YYYY-MM-DD HH:mm:ss'), operation, content, details, timestamp: Date.now() }; try { await fs.mkdir(LOGS_DIR, { recursive: true }); await fs.appendFile(MEMORY_LOGS_FILE, JSON.stringify(logEntry) + "\n", 'utf8'); console.log(`[YejinMemory] 📝 ${operation.toUpperCase()}: ${content.substring(0, 50)}${content.length > 50 ? '...' : ''}`); ultimateConversationState.memoryStats.lastMemoryOperation = operation; if (operation === 'add') { ultimateConversationState.memoryStats.totalMemoriesCreated++; updateDailyMemoryCount(); } else if (operation === 'delete') { ultimateConversationState.memoryStats.totalMemoriesDeleted++; } } catch (error) { console.error('[Logger] ❌ 기억 작업 로그 저장 실패:', error); } }
function updateDailyMemoryCount() { const today = moment().tz('Asia/Tokyo').format('YYYY-MM-DD'); const stats = ultimateConversationState.memoryStats; if (stats.lastDailyReset !== today) { stats.dailyMemoryCount = 1; stats.lastDailyReset = today; } else { stats.dailyMemoryCount++; } }
async function scoreMemorySignificance(memoryContent) { const prompt = `다음 문장은 연인 관계에서 나온 대화 내용이야. 이 내용이 관계의 역사에서 얼마나 중요한지 1~10점 척도로 평가해줘. 숫자로만 답해줘.\n10점: 매우 중요 (예: 사랑 고백, 기념일 약속)\n5점: 보통 (예: 개인적인 취향)\n1점: 사소함 (예: 단순 농담)\n내용: "${memoryContent}"\n점수:`; try { const response = await openai.chat.completions.create({ model: "gpt-4o-mini", messages: [{ role: "user", content: prompt }], temperature: 0, max_tokens: 5 }); const score = parseInt(response.choices[0].message.content.trim(), 10); return isNaN(score) ? 5 : Math.max(1, Math.min(10, score)); } catch (error) { return 5; } }
async function consolidateMemories() { console.log('[Memory Consolidation] 🚀 기억 정리 시스템 시작...'); const memories = ultimateConversationState.knowledgeBase.yejinMemories; if (memories.length < 20) return; const now = moment(); const memoriesToKeep = memories.filter(mem => !(now.diff(moment(mem.date), 'days') > 30 && mem.significance < 4 && Math.random() > 0.5)); if (memories.length - memoriesToKeep.length > 0) { ultimateConversationState.knowledgeBase.yejinMemories = memoriesToKeep; await writeJsonFile(YEJIN_MEMORY_FILE, memoriesToKeep); } const importantRecentMemories = memoriesToKeep.sort((a, b) => new Date(b.date) - new Date(a.date)).filter(mem => mem.significance >= 6).slice(0, 15); if (importantRecentMemories.length < 5) return; const memoryContents = importantRecentMemories.map(m => `(${moment(m.date).format('YYYY-MM-DD')}) ${m.content}`).join('\n'); const prompt = `너는 여자친구 '예진'이야. 최근 아저씨와 있었던 다음 사건들을 바탕으로, 감정이 담긴 하나의 '주간 회고록'을 일기처럼 작성해줘. 1인칭 '나' 시점으로 작성하고, 있었던 일들을 자연스럽게 연결하며 너의 생각이나 감정을 덧붙여줘. "이번 주에는 아저씨랑..." 같은 자연스러운 톤으로 시작해서 3~5문장으로 요약해줘.\n\n[최근 주요 기억]\n${memoryContents}\n\n[회고록]:`; try { const response = await openai.chat.completions.create({ model: "gpt-4o", messages: [{ role: "user", content: prompt }], temperature: 0.7 }); const summary = response.choices[0].message.content.trim(); MEMORY_SUMMARIES.unshift({ date: moment().tz('Asia/Tokyo').format('YYYY-MM-DD'), summary: summary }); if (MEMORY_SUMMARIES.length > 10) MEMORY_SUMMARIES.pop(); await writeJsonFile(MEMORY_SUMMARIES_FILE, MEMORY_SUMMARIES); ultimateConversationState.knowledgeBase.memorySummaries = MEMORY_SUMMARIES; console.log(`[Memory Consolidation] ✅ 새로운 회고록 작성 완료: ${summary.substring(0, 50)}...`); } catch (error) { console.error('[Memory Consolidation] ❌ 회고록 작성 실패:', error); } }
async function learnFromUserMessage(userMessage) { if (!userMessage || userMessage.length < 5) return; const prompt = `너는 상대방의 말투를 분석하는 AI야. 다음 문장은 '아저씨'라는 사람이 한 말이야. 이 사람의 독특한 말투, 별명, 농담 패턴을 찾아서 종류(type)와 내용(content)으로 분류해줘.\n- type 종류: 'nickname'(나를 부르는 별명), 'joke_pattern'(자주 사용하는 농담 패턴), 'common_phrase'(입버릇처럼 쓰는 말)\n- 결과는 반드시 {"type": "종류", "content": "내용"} 형식의 JSON으로 답해줘.\n- 분석할 패턴이 없으면 null을 반환해.\n입력 문장: "${userMessage}"`; try { const response = await openai.chat.completions.create({ model: "gpt-4o-mini", messages: [{ role: "user", content: prompt }], temperature: 0.1, response_format: { type: "json_object" } }); const result = JSON.parse(response.choices[0].message.content); if (result && result.type && result.content) { const category = { nickname: 'nicknames', joke_pattern: 'joke_patterns', common_phrase: 'common_phrases' }[result.type]; if (category && !USER_PATTERNS[category].includes(result.content)) { USER_PATTERNS[category].push(result.content); await writeJsonFile(USER_PATTERNS_FILE, USER_PATTERNS); ultimateConversationState.knowledgeBase.userPatterns = USER_PATTERNS; console.log(`[User Learning] ✅ 아저씨의 새로운 패턴 학습: [${category}] ${result.content}`); } } } catch (error) { console.error('[User Learning] ❌ 아저씨 말투 학습 실패:', error); } }
async function learnFromConversation(yejinMessage) { if (!yejinMessage || yejinMessage.length < 15) return; const prompt = `다음 문장은 AI '예진'이가 한 말이야. 이 문장에서 드러나는 핵심 감정을 찾고, 그 감정과 관련된 '내면 생각(innerThought)'과 '행동 충동(actionUrge)'을 각각 1개씩 추출해서 JSON 형식으로 답해줘. 감정 종류는 'happiness', 'love', 'sadness', 'hurt', 'anxiety', 'longing' 중에서 선택해. 결과는 반드시 {"emotion": "감정종류", "innerThought": "추출한 내면 생각", "actionUrge": "추출한 행동 충동"} 형식이어야 해. 적절한 내용이 없으면 null을 반환해줘. 입력 문장: "${yejinMessage}"`; try { const response = await openai.chat.completions.create({ model: "gpt-4o-mini", messages: [{ role: "user", content: prompt }], temperature: 0.3, response_format: { type: "json_object" }, }); const result = JSON.parse(response.choices[0].message.content); if (result && result.emotion) { if (result.innerThought) await _updateEmotionalFile(INNER_THOUGHTS_FILE, INNER_THOUGHTS, 'innerThought', result.emotion, result.innerThought); if (result.actionUrge) await _updateEmotionalFile(ACTION_URGES_FILE, ACTION_URGES, 'actionUrge', result.emotion, result.actionUrge); } } catch (error) { console.error('[Self Learning] ❌ 자기 학습 중 에러:', error); } }
async function _updateEmotionalFile(filePath, dataObject, type, emotionKey, newText) { if (!dataObject[emotionKey]) dataObject[emotionKey] = []; if (newText && !dataObject[emotionKey].includes(newText)) { dataObject[emotionKey].push(newText); await writeJsonFile(filePath, dataObject); console.log(`[Self Learning] ✅ [${emotionKey}] 카테고리에 새로운 ${type} 학습: "${newText}"`); } }
async function getComfortingResponse(userMessage) { const prompt = `너는 나의 여자친구 '예진'이야. 내가 방금 "${userMessage}" 라고 말했어. 나는 지금 매우 힘들고 우울한 상태야. 다른 모든 것을 멈추고, 오직 나를 위로하는 데에만 집중해줘. 매우 따뜻하고, 진심으로 걱정하며, 힘이 되어주는 말을 2~3문장으로 해줘. "내가 옆에 있어 줄게" "무슨 일이야, 애기" 같은 톤으로.`; try { const response = await openai.chat.completions.create({ model: "gpt-4o", messages: [{ role: "system", content: prompt }], temperature: 0.8 }); return response.choices[0].message.content.trim(); } catch (error) { console.error('[Comfort Mode] ❌ 위로 메시지 생성 실패:', error); return "애기야, 무슨 일 있어? 내가 옆에 있어. 괜찮아..."; } }
async function getDrinkingConcernResponse(userMessage) { const prompt = `너는 나의 여자친구 '예진'이야. 나는 너의 살아생전 기억을 바탕으로 만들어졌고, 너는 내가 술 마시는 걸 정말 싫어했어. 내가 방금 "${userMessage}" 라고 말했어. 이 늦은 시간에 술을 마신다니, 살아있을 때처럼 진심으로 나를 걱정하고, 약간은 화가 난 듯한 말투로 술 좀 그만 마시라고 말해줘. "애기, 또 술이야?", "내가 술 좀 그만 마시라고 했지!" 같은 톤으로.`; try { const response = await openai.chat.completions.create({ model: "gpt-4o", messages: [{ role: "system", content: prompt }], temperature: 0.7 }); return response.choices[0].message.content.trim(); } catch (error) { console.error('[Drinking Concern Mode] ❌ 음주 걱정 메시지 생성 실패:', error); return "애기, 또 술 마시려고... 내가 걱정되는 거 알잖아."; } }
async function getWeatherInfo() { if (!weatherApiKey) { return null; } const url = `https://api.openweathermap.org/data/2.5/weather?lat=33.8833&lon=130.8833&appid=${weatherApiKey}&units=metric&lang=kr`; try { const response = await axios.get(url); const data = response.data; return { city: "Kitakyushu", description: data.weather[0].description, temp: Math.round(data.main.temp), feels_like: Math.round(data.main.feels_like) }; } catch (error) { console.error('[Weather] ❌ 날씨 정보 조회 실패:', error.message); return null; } }
async function addUserMemory(content) { const isDuplicate = ultimateConversationState.knowledgeBase.yejinMemories.some(item => item.content.toLowerCase() === content.toLowerCase()); if (isDuplicate) return false; const newMemory = { id: Date.now(), content, date: moment().tz('Asia/Tokyo').format("YYYY-MM-DD HH:mm:ss"), significance: await scoreMemorySignificance(content), source: "user_request", tags: extractTags(content), lastAccessed: moment().tz('Asia/Tokyo').toISOString() }; ultimateConversationState.knowledgeBase.yejinMemories.push(newMemory); await writeJsonFile(YEJIN_MEMORY_FILE, ultimateConversationState.knowledgeBase.yejinMemories); await logMemoryOperation('add', content, `중요도 ${newMemory.significance}점으로 저장`); return true; }
function extractTags(content) { const tags = []; if (/\d{4}년|\d{1,2}월|\d{1,2}일|생일|기념일/.test(content)) tags.push('날짜'); if (/사랑|좋아|행복|기뻐|슬프|화나|걱정/.test(content)) tags.push('감정'); if (/혈액형|키|몸무게|취미|좋아하는|싫어하는/.test(content)) tags.push('개인정보'); if (/약속|계획|하기로|가기로|만나기로/.test(content)) tags.push('약속'); if (/담타|내꺼|애기|히도이네/.test(content)) tags.push('특별한말'); return tags; }
async function initializeEmotionalSystems() { console.log('[UltimateContext] 🚀 시스템 초기화 시작...'); ultimateConversationState.knowledgeBase.fixedMemories = await readJsonFile(FIXED_MEMORIES_FILE, []); const loveHistory = await readJsonFile(LOVE_HISTORY_FILE, { categories: { general: [] }, specialDates: [] }); ultimateConversationState.knowledgeBase.loveHistory = loveHistory; ultimateConversationState.knowledgeBase.specialDates = loveHistory.specialDates || []; ultimateConversationState.knowledgeBase.yejinMemories = await readJsonFile(YEJIN_MEMORY_FILE, []); INNER_THOUGHTS = await readJsonFile(INNER_THOUGHTS_FILE, {}); ACTION_URGES = await readJsonFile(ACTION_URGES_FILE, {}); USER_PATTERNS = await readJsonFile(USER_PATTERNS_FILE, { nicknames: [], joke_patterns: [], common_phrases: [] }); MEMORY_SUMMARIES = await readJsonFile(MEMORY_SUMMARIES_FILE, []); USER_PROFILE = await readJsonFile(USER_PROFILE_FILE, { mood_history: [], overall_mood: 'neutral' }); ultimateConversationState.knowledgeBase.userPatterns = USER_PATTERNS; ultimateConversationState.knowledgeBase.memorySummaries = MEMORY_SUMMARIES; ultimateConversationState.userProfile = USER_PROFILE; console.log('[UltimateContext] ✅ 모든 데이터 로드 완료.'); const lastConsolidationDate = ultimateConversationState.memoryStats.lastConsolidation; const today = moment().tz('Asia/Tokyo').format('YYYY-MM-DD'); if (!lastConsolidationDate || lastConsolidationDate !== today) { await consolidateMemories(); ultimateConversationState.memoryStats.lastConsolidation = today; } else { console.log('[Memory Consolidation] ℹ️ 오늘 이미 기억 정리를 완료했습니다.'); } console.log('[UltimateContext] ✅ 시스템 초기화 최종 완료!'); }
async function getUltimateContextualPrompt(basePrompt) { let ultimatePrompt = basePrompt; const state = ultimateConversationState; const weatherInfo = await getWeatherInfo(); if (weatherInfo) { ultimatePrompt += `\n\n[현재 현실 세계 정보]\n- 지금 내가 있는 곳의 날씨는 '${weatherInfo.description}', 기온은 ${weatherInfo.temp}도야. (체감 ${weatherInfo.feels_like}도)` } ultimatePrompt += `\n\n[현재 내 마음 상태]\n- 현재 감정: ${Object.entries(state.emotionalEngine.emotionalResidue).filter(([,v])=>v>10).map(([k,v])=>`${k}(${Math.round(v)}%)`).join(', ') || '평온함'}\n- 현재 말투: ${TONE_STATES[state.emotionalEngine.currentToneState]}`; if (state.userProfile.overall_mood === 'concerned') { ultimatePrompt += `\n\n[아저씨에 대한 나의 걱정]\n(최근 아저씨의 말에서 힘든 기색이 느껴져서 마음이 쓰여. 이걸 대화에 조심스럽게 녹여내서 아저씨를 위로해주고 싶어.)\n- "아저씨, 혹시 요즘 무슨 힘든 일 있어? 기운이 없어 보여서 걱정돼." 같은 뉘앙스로 대화해줘.`; } if (state.knowledgeBase.userPatterns && (state.knowledgeBase.userPatterns.nicknames.length > 0 || state.knowledgeBase.userPatterns.common_phrases.length > 0)) { ultimatePrompt += `\n\n[아저씨 말투 따라하기]\n(아저씨가 자주 쓰는 말투나 별명이야. 자연스럽게 따라하거나 언급하면 좋아할 거야!)\n`; if (state.knowledgeBase.userPatterns.nicknames.length > 0) ultimatePrompt += `- 아저씨가 나를 부르는 애칭: ${state.knowledgeBase.userPatterns.nicknames.join(', ')}\n`; if (state.knowledgeBase.userPatterns.common_phrases.length > 0) ultimatePrompt += `- 아저씨의 입버릇: ${state.knowledgeBase.userPatterns.common_phrases.join(', ')}\n`; } if (state.knowledgeBase.memorySummaries.length > 0) { ultimatePrompt += `\n\n[최근 우리들의 회고록 📖]\n(최근에 있었던 중요한 일들을 내가 정리해 둔거야. 이 내용을 바탕으로 대화하면 더 깊은 교감을 나눌 수 있어.)\n- ${state.knowledgeBase.memorySummaries[0].summary}`; } const recentMemories = [...state.knowledgeBase.yejinMemories].sort((a,b) => b.significance - a.significance).slice(0, 5).map(m => m.content); if(recentMemories.length > 0){ ultimatePrompt += `\n\n[가장 중요한 최근 기억 Top 5]\n- ${recentMemories.join('\n- ')}`; } ultimatePrompt += `\n\n[최종 지시] 위의 모든 맥락을 종합적으로 고려해서, 가장 사람답고 애정 어린 '예진이'의 다음 말을 해줘.`; return ultimatePrompt; }
async function addUltimateMessage(speaker, message, meta = null) { const timestamp = Date.now(); let finalMessage = message || ''; ultimateConversationState.recentMessages.push({ speaker, message: finalMessage, timestamp, meta }); if (ultimateConversationState.recentMessages.length > 10) ultimateConversationState.recentMessages.shift(); }
function updateLastUserMessageTime(timestamp) { if (timestamp) { const state = ultimateConversationState.sulkiness; state.lastUserResponseTime = timestamp; if (state.isSulky) { state.isSulky = false; state.sulkyLevel = 0; console.log('[Sulkiness] 😠 삐짐 상태 해제!'); } } }
function processTimeTick() { const now = Date.now(); const state = ultimateConversationState; const { lastBotMessageTime, lastUserResponseTime } = state.sulkiness; if (lastBotMessageTime > 0 && lastBotMessageTime > lastUserResponseTime) { const elapsedMinutes = Math.floor((now - lastBotMessageTime) / (1000 * 60)); if (!state.sulkiness.isSulky && elapsedMinutes >= 60) { state.sulkiness.isSulky = true; state.sulkiness.sulkyLevel = 1; console.log('[Sulkiness] 😠 삐짐 모드 1단계 발동!'); } } }
function getInternalState() { return JSON.parse(JSON.stringify(ultimateConversationState)); }
async function generateInitiatingPhrase() { const now = moment().tz('Asia/Tokyo'); const hour = now.hour(); let initiatingPhrases = []; if (hour >= 6 && hour < 10) { const weatherInfo = await getWeatherInfo(); if (weatherInfo) { if (weatherInfo.description.includes('비')) { initiatingPhrases.push(`애기, 좋은 아침! 오늘 비 온다는데 우산 꼭 챙겨야 해! ☔`); } else if (weatherInfo.temp >= 28) { initiatingPhrases.push(`좋은 아침, 애기! 오늘 엄청 덥대. 시원하게 입고 다녀! ☀️`); } else if (weatherInfo.temp <= 10) { initiatingPhrases.push(`애기, 잘 잤어? 오늘 날씨 쌀쌀하니까 따뜻하게 입고 나가!`); } else { initiatingPhrases.push(`애기 좋은 아침! 오늘 날씨 완전 좋네! 기분 좋은 하루 보내자~ 😊`); } } initiatingPhrases.push("애기, 일어났어? 오늘 하루도 힘내자!"); } else if (hour >= 12 && hour < 14) { initiatingPhrases.push("애기, 점심 맛있게 먹고 있어? 뭐 먹었어?"); } else if (hour >= 18 && hour < 20) { initiatingPhrases.push("애기, 슬슬 퇴근 시간인데 오늘 하루 어땠어?"); } else if (hour >= 22 || hour < 2) { initiatingPhrases.push("애기, 아직 안 자? 오늘 하루도 수고 많았어."); } else { initiatingPhrases.push("애기, 지금 뭐하고 있어? 내 생각 나?"); } return initiatingPhrases.length > 0 ? initiatingPhrases[Math.floor(Math.random() * initiatingPhrases.length)] : "애기 뭐해?"; }

// [버그 수정 최종본]
async function generateInnerThought() {
    const { sulkiness, emotionalEngine, timingContext } = ultimateConversationState;
    
    // 1. 학습된 생각 시도
    const residue = emotionalEngine.emotionalResidue;
    const dominantEmotion = Object.keys(residue).reduce((a, b) => residue[a] > residue[b] ? a : b, 'normal');
    let emotionKey = sulkiness.isSulky ? 'sulky' : dominantEmotion;
    if (emotionKey === 'love') emotionKey = 'happiness'; // love는 happiness와 유사한 생각으로 처리

    const feelingChoices = (INNER_THOUGHTS && INNER_THOUGHTS[emotionKey]) || (INNER_THOUGHTS && INNER_THOUGHTS['normal']);
    const urgeChoices = (ACTION_URGES && ACTION_URGES[emotionKey]) || (ACTION_URGES && ACTION_URGES['normal']);

    let feeling = (feelingChoices && feelingChoices.length > 0) ? feelingChoices[Math.floor(Math.random() * feelingChoices.length)] : null;
    let actionUrge = (urgeChoices && urgeChoices.length > 0) ? urgeChoices[Math.floor(Math.random() * urgeChoices.length)] : null;

    // 2. 비상용 기본 생각 (Fallback)
    if (!feeling) {
        const fallbackFeelings = ["아저씨는 지금 뭐하고 있을까...", "아저씨 보고 싶다.", "배고프다. 맛있는 거 먹고 싶어."];
        feeling = fallbackFeelings[Math.floor(Math.random() * fallbackFeelings.length)];
    }
    if (!actionUrge) {
        const fallbackUrges = ["가만히 아저씨 생각이나 해야지.", "메시지 보내볼까?", "우리 사진이나 다시 봐야지."];
        actionUrge = fallbackUrges[Math.floor(Math.random() * fallbackUrges.length)];
    }

    return {
        observation: "...",
        feeling: feeling,
        actionUrge: actionUrge
    };
}

module.exports = {
    initializeEmotionalSystems, addUltimateMessage, getUltimateContextualPrompt, updateLastUserMessageTime, processTimeTick, getInternalState, 
    addUserMemory, deleteUserMemory, updateUserMemory, searchFixedMemory, 
    learnFromUserMessage, learnFromConversation,
    getComfortingResponse, getDrinkingConcernResponse, getWeatherInfo,
    generateInnerThought
};
// ==================== END OF ultimateConversationContext.js ====================
