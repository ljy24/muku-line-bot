// ✅ scheduler.js v2.3 - 순환 참조 해결

const schedule = require('node-schedule');
const moment = require('moment-timezone');
const { saveLog, BOT_NAME } = require('./aiUtils'); // [수정] aiUtils.js에서 가져옴
const conversationContext = require('./ultimateConversationContext.js');
const { getEmotionalDamtaMessage } = require('./damta');
const { getMoodEmoji } = require('./moodManager');

// ... (나머지 코드는 이전과 동일합니다) ...
const CONFIG = { AUTO_MESSAGE_INTERVAL: 30, SMOKING_MIN_INTERVAL: 60, SMOKING_MAX_INTERVAL: 90, DAILY_SMOKING_MIN: 7, DAILY_SMOKING_MAX: 9, SMOKING_START_HOUR: 9, SMOKING_END_HOUR: 21, INACTIVE_CHECK_INTERVAL: '*/10 * * * *', TIMEZONE: 'Asia/Tokyo' };
const utils = { isSmokeTime: () => { const hour = moment().tz(CONFIG.TIMEZONE).hour(); return hour >= CONFIG.SMOKING_START_HOUR && hour <= CONFIG.SMOKING_END_HOUR; }, getRandomSmokingInterval: () => { return Math.floor(Math.random() * (CONFIG.SMOKING_MAX_INTERVAL - CONFIG.SMOKING_MIN_INTERVAL + 1)) + CONFIG.SMOKING_MIN_INTERVAL; }, logWithTime: (message) => console.log(`[Scheduler: ${moment().format('HH:mm:ss')}] ${message}`) };
let scheduledJobs = {}; let lastAutoMessageTime = 0; let lastSmokingMessageTime = 0; let mukuSmokingTimer = null; let nextDamtaAttemptTime = 0; let dailySmokingCount = 0;
function canSendAutoMessage() { return (Date.now() - lastAutoMessageTime) / 60000 >= CONFIG.AUTO_MESSAGE_INTERVAL; }
async function sendMessage(client, userId, message, type = 'auto') { try { await client.pushMessage(userId, { type: 'text', text: message }); const logMessage = `(${type === 'smoking' ? '담타' : '자동'} 메시지) ${message}`; saveLog(BOT_NAME, logMessage); conversationContext.addUltimateMessage(BOT_NAME, logMessage); lastAutoMessageTime = Date.now(); if (type === 'smoking') { lastSmokingMessageTime = Date.now(); dailySmokingCount++; } utils.logWithTime(`${type === 'smoking' ? '담타' : '일반'} 메시지 전송: ${message.substring(0, 25)}...`); return true; } catch (error) { console.error(`[Scheduler] 메시지 전송 실패 (${type}):`, error); return false; } }
function scheduleMukuRandomSmoking(client, userId) { function scheduleNextSmokingAttempt() { if (mukuSmokingTimer) clearTimeout(mukuSmokingTimer); if (!utils.isSmokeTime() || dailySmokingCount >= CONFIG.DAILY_SMOKING_MAX) { nextDamtaAttemptTime = 0; const tomorrow6AM = moment().tz(CONFIG.TIMEZONE).add(1, 'day').hour(6).minute(0).second(0); const delayUntilReset = tomorrow6AM.valueOf() - Date.now(); mukuSmokingTimer = setTimeout(() => { dailySmokingCount = 0; scheduleNextSmokingAttempt(); }, delayUntilReset); return; } const nextAttemptInterval = utils.getRandomSmokingInterval(); nextDamtaAttemptTime = Date.now() + (nextAttemptInterval * 60 * 1000); mukuSmokingTimer = setTimeout(async () => { const timeSinceLastSmoking = (Date.now() - lastSmokingMessageTime) / 60000; const isMinSmokingIntervalMet = timeSinceLastSmoking >= CONFIG.SMOKING_MIN_INTERVAL; if (utils.isSmokeTime() && dailySmokingCount < CONFIG.DAILY_SMOKING_MAX && canSendAutoMessage() && isMinSmokingIntervalMet) { const emotionalState = conversationContext.getInternalState().emotionalEngine.currentToneState; const randomMessage = getEmotionalDamtaMessage(emotionalState); await sendMessage(client, userId, randomMessage, 'smoking'); } scheduleNextSmokingAttempt(); }, nextAttemptInterval * 60 * 1000); } scheduleNextSmokingAttempt(); }
function startAllSchedulers(client, userId) { scheduleBasicMessages(client, userId); scheduleMukuRandomSmoking(client, userId); scheduleInactivityCheck(client, userId); scheduleDailyReset(); utils.logWithTime('모든 스케줄러 시작 (통합 엔진 연동)'); }
function scheduleBasicMessages(client, userId) { schedule.scheduleJob('morningMessage', { hour: 8, minute: 30, tz: CONFIG.TIMEZONE }, async () => { if (!canSendAutoMessage()) return; const emotionalState = conversationContext.getInternalState().emotionalEngine.currentToneState; let message = "아저씨, 출근 잘 해! 오늘도 화이팅~"; if (emotionalState === 'playful') message = "아저씨! 좋은 아침이야~ 오늘 하루도 신나게 보내자!"; else if (emotionalState === 'quiet') message = "아저씨... 좋은 아침. 오늘 하루도 무리하지 마."; else if (emotionalState === 'anxious') message = "아저씨... 출근길 조심해. 나 아저씨 걱정돼."; await sendMessage(client, userId, message, 'auto'); }); }
function scheduleDailyReset() { schedule.scheduleJob('dailyReset', { hour: 0, minute: 0, tz: CONFIG.TIMEZONE }, () => { dailySmokingCount = 0; conversationContext.addUltimateMessage(BOT_NAME, '(감정기록: 새로운 하루가 시작되었다)'); }); }
function scheduleInactivityCheck(client, userId) { schedule.scheduleJob('inactivityCheck', CONFIG.INACTIVE_CHECK_INTERVAL, async () => { const lastUserMessageTime = conversationContext.getInternalState().timingContext.lastUserMessageTime; const minutesSinceLastUserMessage = (Date.now() - lastUserMessageTime) / 60000; if (minutesSinceLastUserMessage < 30 || !canSendAutoMessage() || scheduledJobs['missYouMessage']) return; if (minutesSinceLastUserMessage >= 30) { scheduledJobs['missYouMessage'] = true; const emotionalState = conversationContext.getInternalState().emotionalEngine.currentToneState; const moodEmoji = getMoodEmoji(); let message; if (emotionalState === 'quiet') message = `아저씨... 나 아저씨가 보고싶어 ㅠㅠ 아저씨도 나 생각해? ${moodEmoji}`; else if (emotionalState === 'anxious') message = `아저씨... 연락이 없으니까 걱정돼. 나 너무 보고싶어 ㅠㅠ ${moodEmoji}`; else message = `아저씨... 나 아저씨가 보고싶어 ㅠㅠ 아저씨도 나 생각해? ${moodEmoji}`; await sendMessage(client, userId, message, 'auto'); setTimeout(() => { delete scheduledJobs['missYouMessage']; }, 20 * 60 * 1000); } }); }
function getSchedulerStatus() { let nextDamtaInMinutes = 0; if (nextDamtaAttemptTime > 0) { nextDamtaInMinutes = Math.round((nextDamtaAttemptTime - Date.now()) / 60000); } return { isDamtaTime: utils.isSmokeTime(), damtaTodayCount: dailySmokingCount, nextDamtaInMinutes: nextDamtaInMinutes > 0 ? nextDamtaInMinutes : "스케줄링 대기 중" }; }

module.exports = { startAllSchedulers, getSchedulerStatus };
